{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport escape from 'escape-string-regexp';\nimport queryString from 'query-string';\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\n\nexport default function getStateFromPath(path, options = {}) {\n  if (path === '') {\n    return undefined;\n  }\n\n  let initialRoutes = []; // Create a normalized configs array which will be easier to use\n\n  const configs = [].concat(...Object.keys(options).map(key => createNormalizedConfigs(key, options, [], initialRoutes)));\n  let result;\n  let current;\n  let remaining = path.replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n  .replace(/^\\//, '') // Remove extra leading slash\n  .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames;\n    let params; // Go through all configs, and see if the next path segment matches our regex\n\n    for (const config of configs) {\n      const match = remaining.match(config.match); // If our regex matches, we need to extract params from the path\n\n      if (match) {\n        routeNames = [...config.routeNames];\n        const paramPatterns = config.pattern.split('/').filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n            return acc;\n          }, {});\n        } // Remove the matched segment from the remaining path\n\n\n        remaining = remaining.replace(match[0], '');\n        break;\n      }\n    } // If we hadn't matched any segments earlier, use the path as route name\n\n\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state;\n    let routeName = routeNames.shift();\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n    state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while (routeName = routeNames.shift()) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0].state;\n        }\n      }\n    }\n\n    if (current) {\n      var _current2; // The state should be nested inside the deepest route we parsed before\n\n\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        var _current;\n\n        current = current.routes[current.index || 0].state;\n      }\n\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    var _current4;\n\n    while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n      var _current3; // The query params apply to the deepest route\n\n\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach(name => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name]);\n        }\n      });\n    }\n\n    route.params = _objectSpread({}, route.params, {}, params);\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(key, routeConfig, routeNames = [], initials) {\n  const configs = [];\n  routeNames.push(key);\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens)\n        });\n      }\n\n      Object.keys(value.screens).forEach(nestedConfig => {\n        const result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n  return configs;\n}\n\nfunction createConfigItem(routeNames, pattern, parse) {\n  const match = new RegExp('^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?');\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse\n  };\n}\n\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n} // tries to find an initial route connected with the one passed\n\n\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName ? undefined : config.initialRouteName;\n    }\n  }\n\n  return undefined;\n} // returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\n\n\nfunction createNestedState(initialRoute, routeName, isEmpty, params) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({\n          name: routeName\n        }, params && {\n          params\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({\n          name: routeName\n        }, params && {\n          params\n        })]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","path","initialRoutes","configs","Object","key","createNormalizedConfigs","remaining","match","config","routeNames","paramPatterns","p","params","value","i","acc","segments","decodeURIComponent","routeName","initialRoute","findInitialRoute","state","createNestedState","nestedState","current","result","query","route","queryString","parseFunction","findParseConfigForRoute","name","routeConfig","createConfigItem","initials","initialRouteName","connectedRoutes","nestedConfig","escape","parse","index","routes"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map(key =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach(name => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach(nestedConfig => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}