{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport Hammer from '@egjs/hammerjs';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"_shouldFireEndEvent\", null);\n\n    _defineProperty(this, \"_timer\", void 0);\n\n    _defineProperty(this, \"_multiTapTimer\", void 0);\n\n    _defineProperty(this, \"onSuccessfulTap\", ev => {\n      if (this._getPendingGestures().length) {\n        this._shouldFireEndEvent = ev;\n        return;\n      }\n\n      if (ev.eventType === Hammer.INPUT_END) {\n        this.sendEvent({ ...ev,\n          eventType: Hammer.INPUT_MOVE\n        });\n      } // When handler gets activated it will turn into State.END immediately.\n\n\n      this.sendEvent({ ...ev,\n        isFinal: true\n      });\n      this.onGestureEnded(ev);\n    });\n  } // TODO unused?\n\n\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    // @ts-ignore TODO(TS) trace down config\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev); // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n\n    if (!this.hasGestureFailed && !this.isGestureRunning && // Prevent multi-pointer events from misfiring.\n    !ev.isFinal) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config\n\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    } // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n\n\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      } // Clear last timer\n\n\n      clearTimeout(this._timer); // Create time out for multi-taps.\n\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config\n\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return { ...super.getHammerConfig(),\n      event: this.name,\n      // @ts-ignore TODO(TS) trace down config\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time: // @ts-ignore TODO(TS) trace down config\n      isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null ? 250 : // @ts-ignore TODO(TS) trace down config\n      this.config.maxDurationMs\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props\n    });\n  }\n\n  onGestureEnded(...props) {\n    clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works\n\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(_gesture) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n\n}\n\nexport default TapGestureHandler;","map":{"version":3,"sources":["TapGestureHandler.ts"],"names":["name","NativeGestureClass","Hammer","maxDelayMs","isnan","simulateCancelEvent","onGestureActivated","ev","eventType","INPUT_MOVE","isFinal","onRawEvent","gesture","clearTimeout","setTimeout","getHammerConfig","event","taps","interval","time","maxDurationMs","updateGestureConfig","shouldCancelWhenOutside","maxDeltaX","Number","maxDeltaY","numberOfTaps","minDurationMs","maxDist","minPointers","maxPointers","props","onGestureEnded","onWaitingEnded"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  private _shouldFireEndEvent: HammerInputExt | null = null;\n  private _timer: any;\n  private _multiTapTimer: any; // TODO unused?\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    // @ts-ignore TODO(TS) trace down config\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = (ev: HammerInputExt) => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev: HammerInput) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      // @ts-ignore TODO(TS) trace down config\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        // @ts-ignore TODO(TS) trace down config\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : // @ts-ignore TODO(TS) trace down config\n            this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props: any) {\n    clearTimeout(this._timer);\n    // @ts-ignore TODO(TS) check how onGestureEnded works\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(_gesture: any) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n"]},"metadata":{},"sourceType":"module"}