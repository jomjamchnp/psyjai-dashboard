{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { StyleSheet, TextInput, Keyboard, I18nManager, InteractionManager } from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { Easing as OldEasing // @ts-ignore\n, EasingNode } from 'react-native-reanimated';\nimport memoize from './memoize';\nconst Easing = EasingNode || OldEasing;\nconst {\n  Clock,\n  Value,\n  onChange,\n  and,\n  or,\n  abs,\n  add,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing\n} = Animated;\nconst PagerContext = /*#__PURE__*/React.createContext({});\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\nconst SWIPE_DISTANCE_MINIMUM = 20;\nconst SWIPE_VELOCITY_IMPACT = 0.2;\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01\n};\nconst SPRING_VELOCITY_SCALE = 1;\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic)\n};\nexport default class Pager extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      enabled: true,\n      childPanGestureHandlerRefs: []\n    });\n\n    _defineProperty(this, \"mounted\", false);\n\n    _defineProperty(this, \"providerVal\", {\n      addGestureHandlerRef: ref => {\n        if (!this.state.childPanGestureHandlerRefs.includes(ref) && this.mounted) {\n          this.setState(prevState => ({\n            childPanGestureHandlerRefs: [...prevState.childPanGestureHandlerRefs, ref]\n          }));\n        }\n      }\n    });\n\n    _defineProperty(this, \"gestureHandlerRef\", /*#__PURE__*/React.createRef());\n\n    _defineProperty(this, \"clock\", new Clock());\n\n    _defineProperty(this, \"velocityX\", new Value(0));\n\n    _defineProperty(this, \"gestureX\", new Value(0));\n\n    _defineProperty(this, \"gestureState\", new Value(State.UNDETERMINED));\n\n    _defineProperty(this, \"offsetX\", new Value(0));\n\n    _defineProperty(this, \"gesturesEnabled\", new Value(1));\n\n    _defineProperty(this, \"progress\", new Value( // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT));\n\n    _defineProperty(this, \"index\", new Value(this.props.navigationState.index));\n\n    _defineProperty(this, \"nextIndex\", new Value(UNSET));\n\n    _defineProperty(this, \"lastEnteredIndex\", new Value(this.props.navigationState.index));\n\n    _defineProperty(this, \"isSwiping\", new Value(FALSE));\n\n    _defineProperty(this, \"isSwipeGesture\", new Value(FALSE));\n\n    _defineProperty(this, \"indexAtSwipeEnd\", new Value(this.props.navigationState.index));\n\n    _defineProperty(this, \"routesLength\", new Value(this.props.navigationState.routes.length));\n\n    _defineProperty(this, \"layoutWidth\", new Value(this.props.layout.width));\n\n    _defineProperty(this, \"swipeVelocityImpact\", new Value(this.props.swipeVelocityImpact !== undefined ? this.props.swipeVelocityImpact : SWIPE_VELOCITY_IMPACT));\n\n    _defineProperty(this, \"springVelocityScale\", new Value(this.props.springVelocityScale !== undefined ? this.props.springVelocityScale : SPRING_VELOCITY_SCALE));\n\n    _defineProperty(this, \"position\", cond(this.layoutWidth, divide(multiply(this.progress, -1), this.layoutWidth), this.index));\n\n    _defineProperty(this, \"springConfig\", {\n      damping: new Value(this.props.springConfig.damping !== undefined ? this.props.springConfig.damping : SPRING_CONFIG.damping),\n      mass: new Value(this.props.springConfig.mass !== undefined ? this.props.springConfig.mass : SPRING_CONFIG.mass),\n      stiffness: new Value(this.props.springConfig.stiffness !== undefined ? this.props.springConfig.stiffness : SPRING_CONFIG.stiffness),\n      restSpeedThreshold: new Value(this.props.springConfig.restSpeedThreshold !== undefined ? this.props.springConfig.restSpeedThreshold : SPRING_CONFIG.restSpeedThreshold),\n      restDisplacementThreshold: new Value(this.props.springConfig.restDisplacementThreshold !== undefined ? this.props.springConfig.restDisplacementThreshold : SPRING_CONFIG.restDisplacementThreshold)\n    });\n\n    _defineProperty(this, \"timingConfig\", {\n      duration: new Value(this.props.timingConfig.duration !== undefined ? this.props.timingConfig.duration : TIMING_CONFIG.duration)\n    });\n\n    _defineProperty(this, \"initialVelocityForSpring\", new Value(0));\n\n    _defineProperty(this, \"currentIndexValue\", this.props.navigationState.index);\n\n    _defineProperty(this, \"pendingIndexValue\", undefined);\n\n    _defineProperty(this, \"previouslyFocusedTextInput\", null);\n\n    _defineProperty(this, \"enterListeners\", []);\n\n    _defineProperty(this, \"interactionHandle\", null);\n\n    _defineProperty(this, \"jumpToIndex\", index => {\n      // If the index changed, we need to trigger a tab switch\n      this.isSwipeGesture.setValue(FALSE);\n      this.nextIndex.setValue(index);\n    });\n\n    _defineProperty(this, \"jumpTo\", key => {\n      const {\n        navigationState,\n        keyboardDismissMode,\n        onIndexChange\n      } = this.props;\n      const index = navigationState.routes.findIndex(route => route.key === key); // A tab switch might occur when we're in the middle of a transition\n      // In that case, the index might be same as before\n      // So we conditionally make the pager to update the position\n\n      if (navigationState.index === index) {\n        this.jumpToIndex(index);\n      } else {\n        onIndexChange(index); // When the index changes, the focused input will no longer be in current tab\n        // So we should dismiss the keyboard\n\n        if (keyboardDismissMode === 'auto') {\n          Keyboard.dismiss();\n        }\n      }\n    });\n\n    _defineProperty(this, \"addListener\", (type, listener) => {\n      switch (type) {\n        case 'enter':\n          this.enterListeners.push(listener);\n          break;\n      }\n    });\n\n    _defineProperty(this, \"removeListener\", (type, listener) => {\n      switch (type) {\n        case 'enter':\n          {\n            const index = this.enterListeners.indexOf(listener);\n\n            if (index > -1) {\n              this.enterListeners.splice(index, 1);\n            }\n\n            break;\n          }\n      }\n    });\n\n    _defineProperty(this, \"handleEnteredIndexChange\", ([value]) => {\n      const index = Math.max(0, Math.min(value, this.props.navigationState.routes.length - 1));\n      this.enterListeners.forEach(listener => listener(index));\n    });\n\n    _defineProperty(this, \"transitionTo\", index => {\n      const toValue = new Value(0);\n      const frameTime = new Value(0);\n      const state = {\n        position: this.progress,\n        time: new Value(0),\n        finished: new Value(FALSE)\n      };\n      return block([cond(clockRunning(this.clock), NOOP, [// Animation wasn't running before\n      // Set the initial values and start the clock\n      set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)), set(frameTime, 0), set(state.time, 0), set(state.finished, FALSE), set(this.index, index)]), cond(this.isSwipeGesture, // Animate the values with a spring for swipe\n      [cond(not(clockRunning(this.clock)), I18nManager.isRTL ? set(this.initialVelocityForSpring, multiply(-1, this.velocityX, this.springVelocityScale)) : set(this.initialVelocityForSpring, multiply(this.velocityX, this.springVelocityScale))), spring(this.clock, _objectSpread(_objectSpread({}, state), {}, {\n        velocity: this.initialVelocityForSpring\n      }), _objectSpread(_objectSpread(_objectSpread({}, SPRING_CONFIG), this.springConfig), {}, {\n        toValue\n      }))], // Otherwise use a timing animation for faster switching\n      timing(this.clock, _objectSpread(_objectSpread({}, state), {}, {\n        frameTime\n      }), _objectSpread(_objectSpread(_objectSpread({}, TIMING_CONFIG), this.timingConfig), {}, {\n        toValue\n      }))), cond(not(clockRunning(this.clock)), startClock(this.clock)), cond(state.finished, [// Reset values\n      set(this.isSwipeGesture, FALSE), set(this.gestureX, 0), set(this.velocityX, 0), // When the animation finishes, stop the clock\n      stopClock(this.clock)])]);\n    });\n\n    _defineProperty(this, \"handleGestureEvent\", event([{\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState\n      }\n    }]));\n\n    _defineProperty(this, \"extrapolatedPosition\", add(this.gestureX, multiply(this.velocityX, this.swipeVelocityImpact)));\n\n    _defineProperty(this, \"toggleEnabled\", () => {\n      if (this.state.enabled && this.mounted) this.setState({\n        enabled: false\n      }, () => {\n        this.setState({\n          enabled: true\n        });\n      });\n    });\n\n    _defineProperty(this, \"maybeCancel\", block([cond(and(this.gesturesEnabled, or(and(eq(this.index, sub(this.routesLength, 1)), lessThan(this.gestureX, 0)), and(eq(this.index, 0), greaterThan(this.gestureX, 0)))), set(this.gesturesEnabled, 0))]));\n\n    _defineProperty(this, \"translateX\", block([onChange(this.gesturesEnabled, cond(not(this.gesturesEnabled), call([this.gesturesEnabled], this.toggleEnabled))), onChange(this.index, call([this.index], ([value]) => {\n      this.currentIndexValue = value; // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n\n      if (value !== this.props.navigationState.index) {\n        // If the index changed, and previous animation has finished, update state\n        this.props.onIndexChange(value);\n        this.pendingIndexValue = value; // Force componentDidUpdate to fire, whether user does a setState or not\n        // This allows us to detect when the user drops the update and revert back\n        // It's necessary to make sure that the state stays in sync\n\n        if (this.mounted) {\n          this.forceUpdate();\n        }\n      }\n    })), onChange(this.position, // Listen to updates in the position to detect when we enter a screen\n    // This is useful for things such as lazy loading when index change will fire too late\n    cond(I18nManager.isRTL ? lessThan(this.gestureX, 0) : greaterThan(this.gestureX, 0), // Based on the direction of the gesture, determine if we're entering the previous or next screen\n    cond(neq(floor(this.position), this.lastEnteredIndex), [set(this.lastEnteredIndex, floor(this.position)), call([floor(this.position)], this.handleEnteredIndexChange)]), cond(neq(ceil(this.position), this.lastEnteredIndex), [set(this.lastEnteredIndex, ceil(this.position)), call([ceil(this.position)], this.handleEnteredIndexChange)]))), onChange(this.isSwiping, // Listen to updates for this value only when it changes\n    // Without `onChange`, this will fire even if the value didn't change\n    // We don't want to call the listeners if the value didn't change\n    [cond(not(this.isSwiping), set(this.gesturesEnabled, 1)), call([this.isSwiping, this.indexAtSwipeEnd, this.index], ([isSwiping, indexAtSwipeEnd, currentIndex]) => {\n      const {\n        keyboardDismissMode,\n        onSwipeStart,\n        onSwipeEnd\n      } = this.props;\n\n      if (isSwiping === TRUE) {\n        onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n        this.interactionHandle = InteractionManager.createInteractionHandle();\n\n        if (keyboardDismissMode === 'auto') {\n          // @ts-ignore: the method is only available in newer React Native, but types aren't up-to-date\n          const input = TextInput.State.currentlyFocusedInput ? // @ts-ignore\n          TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField(); // When a gesture begins, blur the currently focused input\n\n          TextInput.State.blurTextInput(input); // Store the id of this input so we can refocus it if gesture was cancelled\n\n          this.previouslyFocusedTextInput = input;\n        } else if (keyboardDismissMode === 'on-drag') {\n          Keyboard.dismiss();\n        }\n      } else {\n        onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n\n        if (this.interactionHandle !== null) {\n          InteractionManager.clearInteractionHandle(this.interactionHandle);\n        }\n\n        if (keyboardDismissMode === 'auto') {\n          if (indexAtSwipeEnd === currentIndex) {\n            // The index didn't change, we should restore the focus of text input\n            const input = this.previouslyFocusedTextInput;\n\n            if (input) {\n              TextInput.State.focusTextInput(input);\n            }\n          }\n\n          this.previouslyFocusedTextInput = null;\n        }\n      }\n    })]), onChange(this.nextIndex, cond(neq(this.nextIndex, UNSET), [// Stop any running animations\n    cond(clockRunning(this.clock), stopClock(this.clock)), set(this.gestureX, 0), // Update the index to trigger the transition\n    set(this.index, this.nextIndex), set(this.nextIndex, UNSET)])), cond(eq(this.gestureState, State.ACTIVE), [this.maybeCancel, cond(this.isSwiping, NOOP, [// We weren't dragging before, set it to true\n    set(this.isSwiping, TRUE), set(this.isSwipeGesture, TRUE), // Also update the drag offset to the last progress\n    set(this.offsetX, this.progress)]), // Update progress with previous offset + gesture distance\n    set(this.progress, I18nManager.isRTL ? sub(this.offsetX, this.gestureX) : add(this.offsetX, this.gestureX)), // Stop animations while we're dragging\n    stopClock(this.clock)], [set(this.isSwiping, FALSE), set(this.indexAtSwipeEnd, this.index), this.transitionTo(cond(and( // We should consider velocity and gesture distance only when a swipe ends\n    // The gestureX value will be non-zero when swipe has happened\n    // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\n    // For other factors such as state update, the velocity and gesture distance don't matter\n    greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM), greaterThan(abs(this.extrapolatedPosition), divide(this.layoutWidth, 2))), // For swipe gesture, to calculate the index, determine direction and add to index\n    // When the user swipes towards the left, we transition to the next tab\n    // When the user swipes towards the right, we transition to the previous tab\n    round(min(max(0, sub(this.index, cond(greaterThan(this.extrapolatedPosition, 0), I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT, I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT))), sub(this.routesLength, 1))), // Index didn't change/changed due to state update\n    this.index))]), this.progress]));\n\n    _defineProperty(this, \"getTranslateX\", memoize((layoutWidth, routesLength, translateX) => multiply( // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n    min(max(multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT), translateX), 0), I18nManager.isRTL ? -1 : 1)));\n  }\n\n  componentDidMount() {\n    this.mounted = true; // Register this PanGestureHandler with the parent (if parent exists)\n    // in order to coordinate gestures between handlers.\n\n    if (this.context && this.context.addGestureHandlerRef) {\n      this.context.addGestureHandlerRef(this.gestureHandlerRef);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      navigationState,\n      layout,\n      swipeVelocityImpact,\n      springVelocityScale,\n      springConfig,\n      timingConfig\n    } = this.props;\n    const {\n      index,\n      routes\n    } = navigationState;\n\n    if ( // Check for index in state to avoid unintended transition if component updates during swipe\n    index !== prevProps.navigationState.index && index !== this.currentIndexValue || // Check if the user updated the index correctly after an update\n    typeof this.pendingIndexValue === 'number' && index !== this.pendingIndexValue) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    } // Reset the pending index\n\n\n    this.pendingIndexValue = undefined; // Update our mappings of animated nodes when props change\n\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\n      this.swipeVelocityImpact.setValue(swipeVelocityImpact !== undefined ? swipeVelocityImpact : SWIPE_VELOCITY_IMPACT);\n    }\n\n    if (prevProps.springVelocityScale !== springVelocityScale) {\n      this.springVelocityScale.setValue(springVelocityScale !== undefined ? springVelocityScale : SPRING_VELOCITY_SCALE);\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(springConfig.damping !== undefined ? springConfig.damping : SPRING_CONFIG.damping);\n      this.springConfig.mass.setValue(springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass);\n      this.springConfig.stiffness.setValue(springConfig.stiffness !== undefined ? springConfig.stiffness : SPRING_CONFIG.stiffness);\n      this.springConfig.restSpeedThreshold.setValue(springConfig.restSpeedThreshold !== undefined ? springConfig.restSpeedThreshold : SPRING_CONFIG.restSpeedThreshold);\n      this.springConfig.restDisplacementThreshold.setValue(springConfig.restDisplacementThreshold !== undefined ? springConfig.restDisplacementThreshold : SPRING_CONFIG.restDisplacementThreshold);\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(timingConfig.duration !== undefined ? timingConfig.duration : TIMING_CONFIG.duration);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps\n    } = this.props;\n    const translateX = this.getTranslateX(this.layoutWidth, this.routesLength, this.translateX);\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => /*#__PURE__*/React.createElement(PanGestureHandler, _extends({\n        ref: this.gestureHandlerRef,\n        simultaneousHandlers: this.state.childPanGestureHandlerRefs,\n        waitFor: this.state.childPanGestureHandlerRefs,\n        enabled: layout.width !== 0 && swipeEnabled && this.state.enabled,\n        onGestureEvent: this.handleGestureEvent,\n        onHandlerStateChange: this.handleGestureEvent,\n        activeOffsetX: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n        failOffsetY: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]\n      }, gestureHandlerProps), /*#__PURE__*/React.createElement(Animated.View, {\n        removeClippedSubviews: removeClippedSubviews,\n        style: [styles.container, layout.width ? {\n          width: layout.width * navigationState.routes.length,\n          transform: [{\n            translateX\n          }]\n        } : null]\n      }, /*#__PURE__*/React.createElement(PagerContext.Provider, {\n        value: this.providerVal\n      }, children)))\n    });\n  }\n\n}\n\n_defineProperty(Pager, \"defaultProps\", {\n  swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\n  springVelocityScale: SPRING_VELOCITY_SCALE\n});\n\n_defineProperty(Pager, \"contextType\", PagerContext);\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row'\n  }\n});","map":{"version":3,"sources":["Pager.tsx"],"names":["Easing","EasingNode","timing","PagerContext","React","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_VELOCITY_IMPACT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","SPRING_VELOCITY_SCALE","TIMING_CONFIG","duration","easing","Pager","swipeVelocityImpact","springVelocityScale","enabled","childPanGestureHandlerRefs","componentDidMount","componentDidUpdate","timingConfig","routes","index","prevProps","layout","springConfig","componentWillUnmount","InteractionManager","addGestureHandlerRef","ref","prevState","State","cond","divide","multiply","key","onIndexChange","navigationState","route","keyboardDismissMode","Keyboard","Math","listener","toValue","frameTime","state","position","time","finished","block","clockRunning","set","not","I18nManager","spring","velocity","initialVelocityForSpring","startClock","stopClock","event","nativeEvent","translationX","velocityX","gestureState","add","and","or","eq","sub","lessThan","greaterThan","onChange","call","value","neq","floor","ceil","onSwipeEnd","isSwiping","onSwipeStart","input","TextInput","indexAtSwipeEnd","abs","round","min","max","memoize","render","gestureHandlerProps","translateX","children","addListener","removeListener","jumpTo","styles","width","transform","providerVal","container","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  StyleSheet,\n  TextInput,\n  Keyboard,\n  I18nManager,\n  InteractionManager,\n} from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, {\n  Easing as OldEasing,\n  // @ts-ignore\n  EasingNode,\n} from 'react-native-reanimated';\nimport memoize from './memoize';\n\nimport {\n  Layout,\n  NavigationState,\n  Route,\n  Listener,\n  PagerCommonProps,\n  EventEmitterProps,\n} from './types';\n\ntype Binary = 0 | 1;\n\nconst Easing = EasingNode || OldEasing;\n\nexport type Props<T extends Route> = PagerCommonProps & {\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  layout: Layout;\n  // Clip unfocused views to improve memory usage\n  // Don't enable this on iOS where this is buggy and views don't re-appear\n  removeClippedSubviews?: boolean;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.Node<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactNode;\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\n};\n\ntype ComponentState = {\n  enabled: boolean;\n  childPanGestureHandlerRefs: React.RefObject<PanGestureHandler>[];\n};\n\nconst {\n  Clock,\n  Value,\n  onChange,\n  and,\n  or,\n  abs,\n  add,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing,\n} = Animated;\n\nconst PagerContext = React.createContext({});\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\n\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\n\nconst SWIPE_DISTANCE_MINIMUM = 20;\n\nconst SWIPE_VELOCITY_IMPACT = 0.2;\n\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nconst SPRING_VELOCITY_SCALE = 1;\n\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic),\n};\n\nexport default class Pager<T extends Route> extends React.Component<\n  Props<T>,\n  ComponentState\n> {\n  static defaultProps = {\n    swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\n    springVelocityScale: SPRING_VELOCITY_SCALE,\n  };\n\n  state = {\n    enabled: true,\n    childPanGestureHandlerRefs: [] as React.RefObject<PanGestureHandler>[],\n  };\n\n  componentDidMount() {\n    this.mounted = true;\n\n    // Register this PanGestureHandler with the parent (if parent exists)\n    // in order to coordinate gestures between handlers.\n    if (this.context && this.context.addGestureHandlerRef) {\n      this.context.addGestureHandlerRef(this.gestureHandlerRef);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const {\n      navigationState,\n      layout,\n      swipeVelocityImpact,\n      springVelocityScale,\n      springConfig,\n      timingConfig,\n    } = this.props;\n    const { index, routes } = navigationState;\n\n    if (\n      // Check for index in state to avoid unintended transition if component updates during swipe\n      (index !== prevProps.navigationState.index &&\n        index !== this.currentIndexValue) ||\n      // Check if the user updated the index correctly after an update\n      (typeof this.pendingIndexValue === 'number' &&\n        index !== this.pendingIndexValue)\n    ) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    }\n\n    // Reset the pending index\n    this.pendingIndexValue = undefined;\n\n    // Update our mappings of animated nodes when props change\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\n      this.swipeVelocityImpact.setValue(\n        swipeVelocityImpact !== undefined\n          ? swipeVelocityImpact\n          : SWIPE_VELOCITY_IMPACT\n      );\n    }\n\n    if (prevProps.springVelocityScale !== springVelocityScale) {\n      this.springVelocityScale.setValue(\n        springVelocityScale !== undefined\n          ? springVelocityScale\n          : SPRING_VELOCITY_SCALE\n      );\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(\n        springConfig.damping !== undefined\n          ? springConfig.damping\n          : SPRING_CONFIG.damping\n      );\n\n      this.springConfig.mass.setValue(\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\n      );\n\n      this.springConfig.stiffness.setValue(\n        springConfig.stiffness !== undefined\n          ? springConfig.stiffness\n          : SPRING_CONFIG.stiffness\n      );\n\n      this.springConfig.restSpeedThreshold.setValue(\n        springConfig.restSpeedThreshold !== undefined\n          ? springConfig.restSpeedThreshold\n          : SPRING_CONFIG.restSpeedThreshold\n      );\n\n      this.springConfig.restDisplacementThreshold.setValue(\n        springConfig.restDisplacementThreshold !== undefined\n          ? springConfig.restDisplacementThreshold\n          : SPRING_CONFIG.restDisplacementThreshold\n      );\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(\n        timingConfig.duration !== undefined\n          ? timingConfig.duration\n          : TIMING_CONFIG.duration\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  mounted = false;\n\n  static contextType = PagerContext;\n\n  // Mechanism to add child PanGestureHandler refs in the case that this\n  // Pager is a parent to child Pagers. Allows for coordination between handlers\n  private providerVal = {\n    addGestureHandlerRef: (ref: React.RefObject<PanGestureHandler>) => {\n      if (\n        !this.state.childPanGestureHandlerRefs.includes(ref) &&\n        this.mounted\n      ) {\n        this.setState((prevState: ComponentState) => ({\n          childPanGestureHandlerRefs: [\n            ...prevState.childPanGestureHandlerRefs,\n            ref,\n          ],\n        }));\n      }\n    },\n  };\n\n  // PanGestureHandler ref used for coordination with parent handlers\n  private gestureHandlerRef: React.RefObject<\n    PanGestureHandler\n  > = React.createRef();\n\n  // Clock used for tab transition animations\n  private clock = new Clock();\n\n  // Current state of the gesture\n  private velocityX = new Value(0);\n  private gestureX = new Value(0);\n  private gestureState = new Value(State.UNDETERMINED);\n  private offsetX = new Value(0);\n\n  // Tracks current state of gesture handler enabled\n  private gesturesEnabled = new Value(1);\n\n  // Current progress of the page (translateX value)\n  private progress = new Value(\n    // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\n  );\n\n  // Initial index of the tabs\n  private index = new Value(this.props.navigationState.index);\n\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\n\n  // Scene that was last entered\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\n\n  // Whether the user is currently dragging the screen\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\n\n  // Whether the update was due to swipe gesture\n  // This controls whether the transition will use a spring or timing animation\n  // Remember to set it before transition needs to occur\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\n\n  // Track the index value when a swipe gesture has ended\n  // This lets us know if a gesture end triggered a tab switch or not\n  private indexAtSwipeEnd: Animated.Value<number> = new Value(\n    this.props.navigationState.index\n  );\n\n  // Mappings to some prop values\n  // We use them in animation calculations, so we need live animated nodes\n  private routesLength = new Value(this.props.navigationState.routes.length);\n  private layoutWidth = new Value(this.props.layout.width);\n\n  // Determines how relevant is a velocity while calculating next position while swiping\n  private swipeVelocityImpact = new Value(\n    this.props.swipeVelocityImpact !== undefined\n      ? this.props.swipeVelocityImpact\n      : SWIPE_VELOCITY_IMPACT\n  );\n\n  private springVelocityScale = new Value(\n    this.props.springVelocityScale !== undefined\n      ? this.props.springVelocityScale\n      : SPRING_VELOCITY_SCALE\n  );\n\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\n  // It is calculated based on the translate value and layout width\n  // If we don't have the layout yet, we should return the current index\n  private position = cond(\n    this.layoutWidth,\n    divide(multiply(this.progress, -1), this.layoutWidth),\n    this.index\n  );\n\n  // Animation configuration\n  private springConfig = {\n    damping: new Value(\n      this.props.springConfig.damping !== undefined\n        ? this.props.springConfig.damping\n        : SPRING_CONFIG.damping\n    ),\n    mass: new Value(\n      this.props.springConfig.mass !== undefined\n        ? this.props.springConfig.mass\n        : SPRING_CONFIG.mass\n    ),\n    stiffness: new Value(\n      this.props.springConfig.stiffness !== undefined\n        ? this.props.springConfig.stiffness\n        : SPRING_CONFIG.stiffness\n    ),\n    restSpeedThreshold: new Value(\n      this.props.springConfig.restSpeedThreshold !== undefined\n        ? this.props.springConfig.restSpeedThreshold\n        : SPRING_CONFIG.restSpeedThreshold\n    ),\n    restDisplacementThreshold: new Value(\n      this.props.springConfig.restDisplacementThreshold !== undefined\n        ? this.props.springConfig.restDisplacementThreshold\n        : SPRING_CONFIG.restDisplacementThreshold\n    ),\n  };\n\n  private timingConfig = {\n    duration: new Value(\n      this.props.timingConfig.duration !== undefined\n        ? this.props.timingConfig.duration\n        : TIMING_CONFIG.duration\n    ),\n  };\n\n  // The reason for using this value instead of simply passing `this._velocity`\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\n  // Also, it's not possible to pass multiplied value there, because\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\n  // Animated.Value. So this value is being updated on each start of spring animation.\n  private initialVelocityForSpring = new Value(0);\n\n  // The current index change caused by the pager's animation\n  // The pager is used as a controlled component\n  // We need to keep track of the index to determine when to trigger animation\n  // The state will change at various points, we should only respond when we are out of sync\n  // This will ensure smoother animation and avoid weird glitches\n  private currentIndexValue = this.props.navigationState.index;\n\n  // The pending index value as result of state update caused by swipe gesture\n  // We need to set it when state changes from inside this component\n  // It also needs to be reset right after componentDidUpdate fires\n  private pendingIndexValue: number | undefined = undefined;\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n\n  // Listeners for the entered screen\n  private enterListeners: Listener[] = [];\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private jumpToIndex = (index: number) => {\n    // If the index changed, we need to trigger a tab switch\n    this.isSwipeGesture.setValue(FALSE);\n    this.nextIndex.setValue(index);\n  };\n\n  private jumpTo = (key: string) => {\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(\n      (route) => route.key === key\n    );\n\n    // A tab switch might occur when we're in the middle of a transition\n    // In that case, the index might be same as before\n    // So we conditionally make the pager to update the position\n    if (navigationState.index === index) {\n      this.jumpToIndex(index);\n    } else {\n      onIndexChange(index);\n\n      // When the index changes, the focused input will no longer be in current tab\n      // So we should dismiss the keyboard\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\n    const index = Math.max(\n      0,\n      Math.min(value, this.props.navigationState.routes.length - 1)\n    );\n\n    this.enterListeners.forEach((listener) => listener(index));\n  };\n\n  private transitionTo = (index: Animated.Node<number>) => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n\n    const state = {\n      position: this.progress,\n      time: new Value(0),\n      finished: new Value(FALSE),\n    };\n\n    return block([\n      cond(clockRunning(this.clock), NOOP, [\n        // Animation wasn't running before\n        // Set the initial values and start the clock\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\n        set(frameTime, 0),\n        set(state.time, 0),\n        set(state.finished, FALSE),\n        set(this.index, index),\n      ]),\n      cond(\n        this.isSwipeGesture,\n        // Animate the values with a spring for swipe\n        [\n          cond(\n            not(clockRunning(this.clock)),\n            I18nManager.isRTL\n              ? set(\n                  this.initialVelocityForSpring,\n                  multiply(-1, this.velocityX, this.springVelocityScale)\n                )\n              : set(\n                  this.initialVelocityForSpring,\n                  multiply(this.velocityX, this.springVelocityScale)\n                )\n          ),\n          spring(\n            this.clock,\n            { ...state, velocity: this.initialVelocityForSpring },\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\n          ),\n        ],\n        // Otherwise use a timing animation for faster switching\n        timing(\n          this.clock,\n          { ...state, frameTime },\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\n        )\n      ),\n      cond(not(clockRunning(this.clock)), startClock(this.clock)),\n      cond(state.finished, [\n        // Reset values\n        set(this.isSwipeGesture, FALSE),\n        set(this.gestureX, 0),\n        set(this.velocityX, 0),\n        // When the animation finishes, stop the clock\n        stopClock(this.clock),\n      ]),\n    ]);\n  };\n\n  private handleGestureEvent = event([\n    {\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private extrapolatedPosition = add(\n    this.gestureX,\n    multiply(this.velocityX, this.swipeVelocityImpact)\n  );\n\n  private toggleEnabled = () => {\n    if (this.state.enabled && this.mounted)\n      this.setState({ enabled: false }, () => {\n        this.setState({ enabled: true });\n      });\n  };\n\n  // Cancel gesture if swiping back from the initial tab or forward from the last tab.\n  // Enables parent Pager to pick up the gesture if one exists.\n  private maybeCancel = block([\n    cond(\n      and(\n        this.gesturesEnabled,\n        or(\n          and(\n            eq(this.index, sub(this.routesLength, 1)),\n            lessThan(this.gestureX, 0)\n          ),\n          and(eq(this.index, 0), greaterThan(this.gestureX, 0))\n        )\n      ),\n      set(this.gesturesEnabled, 0)\n    ),\n  ]);\n\n  private translateX = block([\n    onChange(\n      this.gesturesEnabled,\n      cond(\n        not(this.gesturesEnabled),\n        call([this.gesturesEnabled], this.toggleEnabled)\n      )\n    ),\n    onChange(\n      this.index,\n      call([this.index], ([value]) => {\n        this.currentIndexValue = value;\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n        if (value !== this.props.navigationState.index) {\n          // If the index changed, and previous animation has finished, update state\n          this.props.onIndexChange(value);\n\n          this.pendingIndexValue = value;\n\n          // Force componentDidUpdate to fire, whether user does a setState or not\n          // This allows us to detect when the user drops the update and revert back\n          // It's necessary to make sure that the state stays in sync\n          if (this.mounted) {\n            this.forceUpdate();\n          }\n        }\n      })\n    ),\n    onChange(\n      this.position,\n      // Listen to updates in the position to detect when we enter a screen\n      // This is useful for things such as lazy loading when index change will fire too late\n      cond(\n        I18nManager.isRTL\n          ? lessThan(this.gestureX, 0)\n          : greaterThan(this.gestureX, 0),\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, floor(this.position)),\n          call([floor(this.position)], this.handleEnteredIndexChange),\n        ]),\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, ceil(this.position)),\n          call([ceil(this.position)], this.handleEnteredIndexChange),\n        ])\n      )\n    ),\n    onChange(\n      this.isSwiping,\n      // Listen to updates for this value only when it changes\n      // Without `onChange`, this will fire even if the value didn't change\n      // We don't want to call the listeners if the value didn't change\n      [\n        cond(not(this.isSwiping), set(this.gesturesEnabled, 1)),\n        call(\n          [this.isSwiping, this.indexAtSwipeEnd, this.index],\n          ([isSwiping, indexAtSwipeEnd, currentIndex]: readonly number[]) => {\n            const {\n              keyboardDismissMode,\n              onSwipeStart,\n              onSwipeEnd,\n            } = this.props;\n\n            if (isSwiping === TRUE) {\n              onSwipeStart?.();\n              this.interactionHandle = InteractionManager.createInteractionHandle();\n\n              if (keyboardDismissMode === 'auto') {\n                // @ts-ignore: the method is only available in newer React Native, but types aren't up-to-date\n                const input = TextInput.State.currentlyFocusedInput\n                  ? // @ts-ignore\n                    TextInput.State.currentlyFocusedInput()\n                  : TextInput.State.currentlyFocusedField();\n\n                // When a gesture begins, blur the currently focused input\n                TextInput.State.blurTextInput(input);\n\n                // Store the id of this input so we can refocus it if gesture was cancelled\n                this.previouslyFocusedTextInput = input;\n              } else if (keyboardDismissMode === 'on-drag') {\n                Keyboard.dismiss();\n              }\n            } else {\n              onSwipeEnd?.();\n\n              if (this.interactionHandle !== null) {\n                InteractionManager.clearInteractionHandle(\n                  this.interactionHandle\n                );\n              }\n\n              if (keyboardDismissMode === 'auto') {\n                if (indexAtSwipeEnd === currentIndex) {\n                  // The index didn't change, we should restore the focus of text input\n                  const input = this.previouslyFocusedTextInput;\n\n                  if (input) {\n                    TextInput.State.focusTextInput(input);\n                  }\n                }\n\n                this.previouslyFocusedTextInput = null;\n              }\n            }\n          }\n        ),\n      ]\n    ),\n    onChange(\n      this.nextIndex,\n      cond(neq(this.nextIndex, UNSET), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), stopClock(this.clock)),\n        set(this.gestureX, 0),\n        // Update the index to trigger the transition\n        set(this.index, this.nextIndex),\n        set(this.nextIndex, UNSET),\n      ])\n    ),\n    cond(\n      eq(this.gestureState, State.ACTIVE),\n      [\n        this.maybeCancel,\n        cond(this.isSwiping, NOOP, [\n          // We weren't dragging before, set it to true\n          set(this.isSwiping, TRUE),\n          set(this.isSwipeGesture, TRUE),\n          // Also update the drag offset to the last progress\n          set(this.offsetX, this.progress),\n        ]),\n        // Update progress with previous offset + gesture distance\n        set(\n          this.progress,\n          I18nManager.isRTL\n            ? sub(this.offsetX, this.gestureX)\n            : add(this.offsetX, this.gestureX)\n        ),\n        // Stop animations while we're dragging\n        stopClock(this.clock),\n      ],\n      [\n        set(this.isSwiping, FALSE),\n        set(this.indexAtSwipeEnd, this.index),\n        this.transitionTo(\n          cond(\n            and(\n              // We should consider velocity and gesture distance only when a swipe ends\n              // The gestureX value will be non-zero when swipe has happened\n              // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\n              // For other factors such as state update, the velocity and gesture distance don't matter\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\n              greaterThan(\n                abs(this.extrapolatedPosition),\n                divide(this.layoutWidth, 2)\n              )\n            ),\n            // For swipe gesture, to calculate the index, determine direction and add to index\n            // When the user swipes towards the left, we transition to the next tab\n            // When the user swipes towards the right, we transition to the previous tab\n            round(\n              min(\n                max(\n                  0,\n                  sub(\n                    this.index,\n                    cond(\n                      greaterThan(this.extrapolatedPosition, 0),\n                      I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                      I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                    )\n                  )\n                ),\n                sub(this.routesLength, 1)\n              )\n            ),\n            // Index didn't change/changed due to state update\n            this.index\n          )\n        ),\n      ]\n    ),\n    this.progress,\n  ]);\n\n  private getTranslateX = memoize(\n    (\n      layoutWidth: Animated.Node<number>,\n      routesLength: Animated.Node<number>,\n      translateX: Animated.Node<number>\n    ) =>\n      multiply(\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n        min(\n          max(\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\n            translateX\n          ),\n          0\n        ),\n        I18nManager.isRTL ? -1 : 1\n      )\n  );\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps,\n    } = this.props;\n\n    const translateX = this.getTranslateX(\n      this.layoutWidth,\n      this.routesLength,\n      this.translateX\n    );\n\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: (children) => (\n        <PanGestureHandler\n          ref={this.gestureHandlerRef}\n          simultaneousHandlers={this.state.childPanGestureHandlerRefs}\n          waitFor={this.state.childPanGestureHandlerRefs}\n          enabled={layout.width !== 0 && swipeEnabled && this.state.enabled}\n          onGestureEvent={this.handleGestureEvent}\n          onHandlerStateChange={this.handleGestureEvent}\n          activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          {...gestureHandlerProps}\n        >\n          <Animated.View\n            removeClippedSubviews={removeClippedSubviews}\n            style={[\n              styles.container,\n              layout.width\n                ? {\n                    width: layout.width * navigationState.routes.length,\n                    transform: [{ translateX }] as any,\n                  }\n                : null,\n            ]}\n          >\n            <PagerContext.Provider value={this.providerVal}>\n              {children}\n            </PagerContext.Provider>\n          </Animated.View>\n        </PanGestureHandler>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}