{"ast":null,"code":"/* eslint-disable eslint-comments/no-unlimited-disable */\n\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria({\n    x,\n    y,\n    deltaX,\n    deltaY\n  }, {\n    maxDeltaX,\n    maxDeltaY,\n    maxDistSq,\n    shouldCancelWhenOutside\n  }) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({\n        x,\n        y\n      })) {\n        return true;\n      }\n    }\n\n    return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n  }\n\n  transformNativeEvent({\n    center: {\n      x,\n      y\n    }\n  }) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view.getBoundingClientRect();\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top\n    };\n  }\n\n  isGestureEnabledForEvent({\n    minPointers,\n    maxPointers,\n    maxDeltaX,\n    maxDeltaY,\n    maxDistSq,\n    shouldCancelWhenOutside\n  }, _recognizer, {\n    maxPointers: pointerLength,\n    center,\n    deltaX,\n    deltaY\n  }) {\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (this.shouldFailUnderCustomCriteria({ ...center,\n      deltaX,\n      deltaY\n    }, {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    }) || // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n    // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n    !validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n\n    return {\n      success: validPointerCount\n    };\n  }\n\n}\n\nexport default DiscreteGestureHandler;","map":{"version":3,"sources":["DiscreteGestureHandler.ts"],"names":["isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","deltaY","shouldCancelWhenOutside","y","TEST_MAX_IF_NOT_NAN","Math","deltaX","transformNativeEvent","center","rect","absoluteX","absoluteY","x","top","isGestureEnabledForEvent","maxPointers","validPointerCount","pointerLength","failed","success"],"mappings":"AAAA;;AACA;AACA,OAAA,cAAA,MAAA,kBAAA;AACA,SAAA,mBAAA,QAAA,SAAA;;AAEA,MAAA,sBAAA,SAAA,cAAA,CAA6D;AAC7C,MAAVA,UAAU,GAAG;AACf,WAAA,IAAA;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAA,IAAA;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAA,IAAA,CAAA;AAAA,IAAA,CAAA;AAAA,IAAA,MAAA;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAA,IAAA,SAAA;AAAA,IAAA,SAAA;AAAA,IAAA,SAAA;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAA,uBAAA,EAA6B;AAC3B,UAAI,CAAC,KAAA,aAAA,CAAmB;AAAA,QAAA,CAAA;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAA,IAAA;AACD;AACF;;AACD,WACEC,mBAAmB,CAACC,IAAI,CAAJA,GAAAA,CAAD,MAACA,CAAD,EAAnBD,SAAmB,CAAnBA,IACAA,mBAAmB,CAACC,IAAI,CAAJA,GAAAA,CAAD,MAACA,CAAD,EADnBD,SACmB,CADnBA,IAEAA,mBAAmB,CACjBC,IAAI,CAAJA,GAAAA,CAASJ,MAAM,GAANA,MAAAA,GAAkBK,MAAM,GADhB,MACjBD,CADiB,EAHrB,SAGqB,CAHrB;AAQD;;AAEDE,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAA,MAAA,CAAA;AAAKL,MAAAA;AAAL;AAAV,GAAD,EAA4B;AAC9C;AACA,UAAMM,IAAI,GAAG,KAAA,IAAA,CAAb,qBAAa,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EADJ,CAAA;AAELC,MAAAA,SAAS,EAFJ,CAAA;AAGLC,MAAAA,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAHN,IAAA;AAILN,MAAAA,CAAC,EAAEA,CAAC,GAAGM,IAAI,CAACI;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAA,IAAA,WAAA;AAAA,IAAA,WAAA;AAAA,IAAA,SAAA;AAAA,IAAA,SAAA;AAAA,IAAA,SAAA;AAMEZ,IAAAA;AANF,GADsB,EAAA,WAAA,EAUtB;AAAEa,IAAAA,WAAW,EAAb,aAAA;AAAA,IAAA,MAAA;AAAA,IAAA,MAAA;AAA8Cd,IAAAA;AAA9C,GAVsB,EAWtB;AACA,UAAMe,iBAAiB,GACrBC,aAAa,IAAbA,WAAAA,IAAgCA,aAAa,IAD/C,WAAA;;AAGA,QACE,KAAA,6BAAA,CACE,EAAE,GAAF,MAAA;AAAA,MAAA,MAAA;AAAqBhB,MAAAA;AAArB,KADF,EAEE;AAAA,MAAA,SAAA;AAAA,MAAA,SAAA;AAAA,MAAA,SAAA;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAAA,iBAAA,IAAsB,KAZzB,gBAAA,EAaE;AACA,aAAO;AAAEgB,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;AA4E7D,eAAA,sBAAA","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]},"metadata":{},"sourceType":"module"}