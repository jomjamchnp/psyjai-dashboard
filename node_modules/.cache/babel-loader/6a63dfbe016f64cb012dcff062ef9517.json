{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { View, StyleSheet } from 'react-native';\nexport default class SceneView extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      loading: Math.abs(this.props.navigationState.index - this.props.index) > this.props.lazyPreloadDistance\n    });\n\n    _defineProperty(this, \"handleEnter\", value => {\n      const {\n        index\n      } = this.props; // If we're entering the current route, we need to load it\n\n      if (value === index && this.state.loading) {\n        this.setState({\n          loading: false\n        });\n      }\n    });\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (state.loading && Math.abs(props.navigationState.index - props.index) <= props.lazyPreloadDistance) {\n      // Always render the route when it becomes focused\n      return {\n        loading: false\n      };\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this.props.lazy) {\n      // If lazy mode is enabled, listen to when we enter screens\n      this.props.addListener('enter', this.handleEnter);\n    } else if (this.state.loading) {\n      // If lazy mode is not enabled, render the scene with a delay if not loaded already\n      // This improves the initial startup time as the scene is no longer blocking\n      setTimeout(() => this.setState({\n        loading: false\n      }), 0);\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.lazy !== prevProps.lazy || this.state.loading !== prevState.loading) {\n      // We only need the listener if the tab hasn't loaded yet and lazy is enabled\n      if (this.props.lazy && this.state.loading) {\n        this.props.addListener('enter', this.handleEnter);\n      } else {\n        this.props.removeListener('enter', this.handleEnter);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.removeListener('enter', this.handleEnter);\n  }\n\n  render() {\n    const {\n      navigationState,\n      index,\n      layout,\n      style\n    } = this.props;\n    const {\n      loading\n    } = this.state;\n    const focused = navigationState.index === index;\n    return /*#__PURE__*/React.createElement(View, {\n      accessibilityElementsHidden: !focused,\n      importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',\n      style: [styles.route, // If we don't have the layout yet, make the focused screen fill the container\n      // This avoids delay before we are able to render pages side by side\n      layout.width ? {\n        width: layout.width\n      } : focused ? StyleSheet.absoluteFill : null, style]\n    }, // Only render the route only if it's either focused or layout is available\n    // When layout is not available, we must not render unfocused routes\n    // so that the focused route can fill the screen\n    focused || layout.width ? this.props.children({\n      loading\n    }) : null);\n  }\n\n}\nconst styles = StyleSheet.create({\n  route: {\n    flex: 1,\n    overflow: 'hidden'\n  }\n});","map":{"version":3,"sources":["SceneView.tsx"],"names":["React","getDerivedStateFromProps","state","Math","props","loading","lazyPreloadDistance","componentDidMount","setTimeout","componentDidUpdate","prevProps","prevState","componentWillUnmount","value","index","render","style","focused","navigationState","styles","layout","width","StyleSheet","route","flex","overflow"],"mappings":";;;;;;;;;;;;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,SAAA,IAAA,EAAA,UAAA,QAAA,cAAA;AAsBA,eAAe,MAAA,SAAA,SAAyCA,KAAK,CAA9C,SAAA,CAGb;AAAA,EAAA,WAAA,CAAA,GAAA,IAAA,EAAA;AAAA,UAAA,GAAA,IAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,OAAA,EAcQ;AACNK,MAAAA,OAAO,EACLF,IAAI,CAAJA,GAAAA,CAAS,KAAA,KAAA,CAAA,eAAA,CAAA,KAAA,GAAmC,KAAA,KAAA,CAA5CA,KAAAA,IACA,KAAA,KAAA,CAAWG;AAHP,KAdR,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,EAiDuBO,KAAD,IAAmB;AACvC,YAAM;AAAEC,QAAAA;AAAF,UAAY,KADqB,KACvC,CADuC,CAGvC;;AACA,UAAID,KAAK,KAALA,KAAAA,IAAmB,KAAA,KAAA,CAAvB,OAAA,EAA2C;AACzC,aAAA,QAAA,CAAc;AAAER,UAAAA,OAAO,EAAE;AAAX,SAAd;AACD;AAvDH,KAAA,CAAA;AAAA;;AACA,SAAOJ,wBAAP,CAAA,KAAA,EAAA,KAAA,EAAmE;AACjE,QACEC,KAAK,CAALA,OAAAA,IACAC,IAAI,CAAJA,GAAAA,CAASC,KAAK,CAALA,eAAAA,CAAAA,KAAAA,GAA8BA,KAAK,CAA5CD,KAAAA,KACEC,KAAK,CAHT,mBAAA,EAIE;AACA;AACA,aAAO;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAAP;AACD;;AAED,WAAA,IAAA;AACD;;AAQDE,EAAAA,iBAAiB,GAAG;AAClB,QAAI,KAAA,KAAA,CAAJ,IAAA,EAAqB;AACnB;AACA,WAAA,KAAA,CAAA,WAAA,CAAA,OAAA,EAAgC,KAAhC,WAAA;AAFF,KAAA,MAGO,IAAI,KAAA,KAAA,CAAJ,OAAA,EAAwB;AAC7B;AACA;AACAC,MAAAA,UAAU,CAAC,MAAM,KAAA,QAAA,CAAc;AAAEH,QAAAA,OAAO,EAAE;AAAX,OAAd,CAAP,EAAVG,CAAU,CAAVA;AACD;AACF;;AAEDC,EAAAA,kBAAkB,CAAA,SAAA,EAAA,SAAA,EAAwC;AACxD,QACE,KAAA,KAAA,CAAA,IAAA,KAAoBC,SAAS,CAA7B,IAAA,IACA,KAAA,KAAA,CAAA,OAAA,KAAuBC,SAAS,CAFlC,OAAA,EAGE;AACA;AACA,UAAI,KAAA,KAAA,CAAA,IAAA,IAAmB,KAAA,KAAA,CAAvB,OAAA,EAA2C;AACzC,aAAA,KAAA,CAAA,WAAA,CAAA,OAAA,EAAgC,KAAhC,WAAA;AADF,OAAA,MAEO;AACL,aAAA,KAAA,CAAA,cAAA,CAAA,OAAA,EAAmC,KAAnC,WAAA;AACD;AACF;AACF;;AAEDC,EAAAA,oBAAoB,GAAG;AACrB,SAAA,KAAA,CAAA,cAAA,CAAA,OAAA,EAAmC,KAAnC,WAAA;AACD;;AAWDG,EAAAA,MAAM,GAAG;AACP,UAAM;AAAA,MAAA,eAAA;AAAA,MAAA,KAAA;AAAA,MAAA,MAAA;AAAkCC,MAAAA;AAAlC,QAA4C,KAAlD,KAAA;AACA,UAAM;AAAEX,MAAAA;AAAF,QAAc,KAApB,KAAA;AAEA,UAAMY,OAAO,GAAGC,eAAe,CAAfA,KAAAA,KAAhB,KAAA;AAEA,WAAA,aACE,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACE,MAAA,2BAA2B,EAAE,CAD/B,OAAA;AAEE,MAAA,yBAAyB,EAAED,OAAO,GAAA,MAAA,GAFpC,qBAAA;AAGE,MAAA,KAAK,EAAE,CACLE,MAAM,CADD,KAAA,EAEL;AACA;AACAC,MAAAA,MAAM,CAANA,KAAAA,GACI;AAAEC,QAAAA,KAAK,EAAED,MAAM,CAACC;AAAhB,OADJD,GAEIH,OAAO,GACPK,UAAU,CADH,YAAA,GANN,IAAA,EAAA,KAAA;AAHT,KAAA,EAgBI;AACA;AACA;AACAL,IAAAA,OAAO,IAAIG,MAAM,CAAjBH,KAAAA,GAA0B,KAAA,KAAA,CAAA,QAAA,CAAoB;AAAEZ,MAAAA;AAAF,KAApB,CAA1BY,GApBN,IACE,CADF;AAwBD;;AAxFD;AA2FF,MAAME,MAAM,GAAG,UAAU,CAAV,MAAA,CAAkB;AAC/BI,EAAAA,KAAK,EAAE;AACLC,IAAAA,IAAI,EADC,CAAA;AAELC,IAAAA,QAAQ,EAAE;AAFL;AADwB,CAAlB,CAAf","sourcesContent":["import * as React from 'react';\nimport { View, StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport {\n  SceneRendererProps,\n  EventEmitterProps,\n  NavigationState,\n  Route,\n} from './types';\n\ntype Props<T extends Route> = SceneRendererProps &\n  EventEmitterProps & {\n    navigationState: NavigationState<T>;\n    lazy: boolean;\n    lazyPreloadDistance: number;\n    index: number;\n    children: (props: { loading: boolean }) => React.ReactNode;\n    style?: StyleProp<ViewStyle>;\n  };\n\ntype State = {\n  loading: boolean;\n};\n\nexport default class SceneView<T extends Route> extends React.Component<\n  Props<T>,\n  State\n> {\n  static getDerivedStateFromProps(props: Props<Route>, state: State) {\n    if (\n      state.loading &&\n      Math.abs(props.navigationState.index - props.index) <=\n        props.lazyPreloadDistance\n    ) {\n      // Always render the route when it becomes focused\n      return { loading: false };\n    }\n\n    return null;\n  }\n\n  state = {\n    loading:\n      Math.abs(this.props.navigationState.index - this.props.index) >\n      this.props.lazyPreloadDistance,\n  };\n\n  componentDidMount() {\n    if (this.props.lazy) {\n      // If lazy mode is enabled, listen to when we enter screens\n      this.props.addListener('enter', this.handleEnter);\n    } else if (this.state.loading) {\n      // If lazy mode is not enabled, render the scene with a delay if not loaded already\n      // This improves the initial startup time as the scene is no longer blocking\n      setTimeout(() => this.setState({ loading: false }), 0);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>, prevState: State) {\n    if (\n      this.props.lazy !== prevProps.lazy ||\n      this.state.loading !== prevState.loading\n    ) {\n      // We only need the listener if the tab hasn't loaded yet and lazy is enabled\n      if (this.props.lazy && this.state.loading) {\n        this.props.addListener('enter', this.handleEnter);\n      } else {\n        this.props.removeListener('enter', this.handleEnter);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.removeListener('enter', this.handleEnter);\n  }\n\n  private handleEnter = (value: number) => {\n    const { index } = this.props;\n\n    // If we're entering the current route, we need to load it\n    if (value === index && this.state.loading) {\n      this.setState({ loading: false });\n    }\n  };\n\n  render() {\n    const { navigationState, index, layout, style } = this.props;\n    const { loading } = this.state;\n\n    const focused = navigationState.index === index;\n\n    return (\n      <View\n        accessibilityElementsHidden={!focused}\n        importantForAccessibility={focused ? 'auto' : 'no-hide-descendants'}\n        style={[\n          styles.route,\n          // If we don't have the layout yet, make the focused screen fill the container\n          // This avoids delay before we are able to render pages side by side\n          layout.width\n            ? { width: layout.width }\n            : focused\n            ? StyleSheet.absoluteFill\n            : null,\n          style,\n        ]}\n      >\n        {\n          // Only render the route only if it's either focused or layout is available\n          // When layout is not available, we must not render unfocused routes\n          // so that the focused route can fill the screen\n          focused || layout.width ? this.props.children({ loading }) : null\n        }\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  route: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}