{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport Hammer from '@egjs/hammerjs';\nimport { State } from '../State';\nimport { CONTENT_TOUCHES_DELAY, CONTENT_TOUCHES_QUICK_TAP_END_DELAY } from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"visualFeedbackTimer\", void 0);\n\n    _defineProperty(this, \"initialEvent\", null);\n\n    _defineProperty(this, \"shouldDelayTouches\", true);\n  }\n\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    // @ts-ignore FIXME(TS)\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  simulateCancelEvent(inputData) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({\n    shouldCancelWhenOutside,\n    maxDistSq\n  }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type) {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED\n    }[type];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10\n      };\n    }\n\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return { ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs\n    };\n  }\n\n  onGestureActivated(ev) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({\n    pointerType\n  }) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({ ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true\n    });\n  }\n\n  forceInvalidate(event) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n\n    if (this.isGestureRunning) {\n      if (ev.isFinal) {\n        let timeout;\n\n        if (this.visualFeedbackTimer) {\n          // Aesthetic timing for a quick tap.\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n          this.sendGestureStartedEvent(this.initialEvent);\n          this.initialEvent = null;\n        }\n\n        fireAfterInterval(() => {\n          this.sendEvent({ ...ev,\n            eventType: Hammer.INPUT_END,\n            isFinal: true\n          }); // @ts-ignore -- this should explicitly support undefined\n\n          this.onGestureEnded();\n        }, timeout);\n      } else {\n        this.sendEvent({ ...ev,\n          eventType: Hammer.INPUT_MOVE,\n          isFinal: false\n        });\n      }\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props\n    });\n  }\n\n}\n\nexport default PressGestureHandler;","map":{"version":3,"sources":["PressGestureHandler.ts"],"names":["name","minDurationMs","isnan","maxDist","NativeGestureClass","Hammer","simulateCancelEvent","updateHasCustomActivationCriteria","maxDistSq","shouldCancelWhenOutside","isValidNumber","getState","State","CANCELLED","getConfig","getHammerConfig","time","onGestureActivated","shouldDelayTouchForEvent","pointerType","onGestureStart","clearTimeout","fireAfterInterval","sendGestureStartedEvent","eventType","isFirst","forceInvalidate","onRawEvent","ev","timeout","isFinal","updateGestureConfig","shouldActivateOnStart","disallowInterruption","Number","minPointers","maxPointers","props"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport {\n  CONTENT_TOUCHES_DELAY,\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\n  HammerInputNames,\n} from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { Config, HammerInputExt } from './GestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  private visualFeedbackTimer: any;\n  private initialEvent: HammerInputExt | null = null;\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    // @ts-ignore FIXME(TS)\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  shouldDelayTouches = true;\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({\n    shouldCancelWhenOutside,\n    maxDistSq,\n  }: Config & { shouldCancelWhenOutside: boolean }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type: keyof typeof HammerInputNames): State {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\n    }[type];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev: HammerInputExt) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev: HammerInputExt) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({\n      ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true,\n    });\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.isGestureRunning) {\n      if (ev.isFinal) {\n        let timeout;\n        if (this.visualFeedbackTimer) {\n          // Aesthetic timing for a quick tap.\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n          this.initialEvent = null;\n        }\n        fireAfterInterval(() => {\n          this.sendEvent({\n            ...ev,\n            eventType: Hammer.INPUT_END,\n            isFinal: true,\n          });\n          // @ts-ignore -- this should explicitly support undefined\n          this.onGestureEnded();\n        }, timeout);\n      } else {\n        this.sendEvent({\n          ...ev,\n          eventType: Hammer.INPUT_MOVE,\n          isFinal: false,\n        });\n      }\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n}\nexport default PressGestureHandler;\n"]},"metadata":{},"sourceType":"module"}