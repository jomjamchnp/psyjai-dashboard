{"ast":null,"code":"/* eslint-disable eslint-comments/no-unlimited-disable */\n\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event) {\n    this.sendEvent({ ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({ ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true\n    });\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n\n    if (this.hasGestureFailed) {\n      return;\n    } // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n\n\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name); // @ts-ignore FIXME(TS)\n\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection()\n    };\n  }\n\n  getTargetDirections(direction) {\n    const directions = [];\n\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    } // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n\n\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const {\n      direction\n    } = this.getConfig();\n    let directions = [];\n\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n\n    directions = [...new Set(directions)];\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent({\n    numberOfPointers\n  }, _recognizer, {\n    maxPointers: pointerLength\n  }) {\n    const validPointerCount = pointerLength === numberOfPointers;\n\n    if (!validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n\n    return {\n      success: validPointerCount\n    };\n  }\n\n  updateGestureConfig({\n    numberOfPointers = 1,\n    direction,\n    ...props\n  }) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props\n    });\n  }\n\n}\n\nexport default FlingGestureHandler;","map":{"version":3,"sources":["FlingGestureHandler.ts"],"names":["name","NativeGestureClass","Hammer","onGestureActivated","eventType","isFinal","isFirst","onRawEvent","ev","setTimeout","gesture","getHammerConfig","pointers","direction","getTargetDirections","directions","Direction","getDirection","isGestureEnabledForEvent","numberOfPointers","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props","isnan"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]},"metadata":{},"sourceType":"module"}